using System.Collections.Immutable;
using System.Security.Cryptography.X509Certificates;
using Cubist.Germanium.CSharp;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Cubist.Germanium.Generators.SignalRBridge;

/// <summary>  </summary>
[Generator]
public class SignalRBridgeGenerator : IIncrementalGenerator
{

    /// <summary>  </summary>
    public const string HubClassSyntaxProviderTrackingName = "HubClassSyntaxProvider";

    /// <summary>  </summary>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var hubClasses = context.SyntaxProvider
            .CreateSyntaxProvider(IsHubImplementation, GetHubClassInfo)
            .WithTrackingName(HubClassSyntaxProviderTrackingName)
            .Where(info => info != null)
            .Select((info, _) => info!)
            .Collect();

        context.RegisterSourceOutput(hubClasses, GenerateHubImplementation);
    }

    private bool IsHubImplementation(SyntaxNode node, CancellationToken cancellationToken)
    {
        // 2 base types, first is Hub<T>, second is the interface
        if (node is ClassDeclarationSyntax { BaseList.Types.Count: 2 } cds)
        {
            var typeSyntax = cds.BaseList.Types[0].Type;
            return typeSyntax.Accept(GenericTypeNameVisitor.Hub);
        }
        return false;
    }

    private HubInfo? GetHubClassInfo(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var hubSymbol = (INamedTypeSymbol?)context.SemanticModel.GetDeclaredSymbol(context.Node, cancellationToken);
        if (hubSymbol == null) return null;

        var hubType = GetTypeInfo(hubSymbol);

        if (hubSymbol.BaseType == null) return null;
        var baseType = hubSymbol.BaseType;// SomeHub : Hub<T>, SomeInterface -> Hub<T>
        if (baseType.TypeParameters.Length != 1) return null;
        var clientTypeSymbol = baseType.TypeArguments[0] as INamedTypeSymbol; // Hub<T> -> T
        if (clientTypeSymbol == null) return null;

        var clientType = GetTypeInfo(clientTypeSymbol);
        var clientInterface = new InterfaceInfo(clientType, GetMethodInfo(clientType, clientTypeSymbol));

        if (hubSymbol.Interfaces.Length != 1) return null;
        var serverTypeSymbol = hubSymbol.Interfaces[0]; // SomeHub : Hub<T>, SomeInterface -> SomeInterface
        var serverType = GetTypeInfo(serverTypeSymbol);
        var serverInterface = new InterfaceInfo(serverType, GetMethodInfo(serverType, serverTypeSymbol));
        return new HubInfo(hubType, clientInterface, serverInterface);
    }

    private MethodInfo[] GetMethodInfo(TypeInfo declaringType, INamedTypeSymbol interfaceSymbol)
    {
        var methods = new List<MethodInfo>();
        foreach (var m in interfaceSymbol.GetMembers().OfType<IMethodSymbol>())
        {
            var returnType = GetTypeInfo(m.ReturnType);
            var parameters = m.Parameters.Select(p => new ParameterInfo(p.Name, GetTypeInfo(p.Type))).ToArray();
            var method = new MethodInfo(m.Name, returnType, declaringType, parameters);
            methods.Add(method);
        }
        return methods.ToArray();
    }

    private static TypeInfo GetTypeInfo(ITypeSymbol typeSymbol, int recursionLevel = 0)
    {
        if (recursionLevel > 10) throw new InvalidOperationException($"Generic type recursion on type {typeSymbol.ToDisplayString()}");
        if (typeSymbol is INamedTypeSymbol namedTypeSymbol)
        {
            try
            {
                var typeParameters = namedTypeSymbol.TypeParameters
                    .Select(t => GetTypeInfo(t, recursionLevel + 1))
                    .ToArray();
                return new TypeInfo(namedTypeSymbol.ContainingNamespace.ToDisplayString(), namedTypeSymbol.Name, typeParameters);
            }
            catch (InvalidOperationException e)
            {
                throw new InvalidOperationException(e.Message + " <- " + typeSymbol.ToDisplayString(), e);
            }
        }
        return new(typeSymbol.ContainingNamespace.ToDisplayString(), typeSymbol.Name);
    }

    private void GenerateHubImplementation(SourceProductionContext context, ImmutableArray<HubInfo> hubs)
    {
        var source = new CodeWriter();
        source.WriteComment("<auto-generated />");
        source.WriteComment($"{hubs.Length} hub{(hubs.Length == 1 ? "" : "s")} found");
        source.WriteLine();

        foreach (var hub in hubs)
        {
            GenerateHubImplementation(context, source, hub);
        }

        context.AddSource($"{nameof(SignalRBridgeGenerator)}.g.cs", source.ToString());
    }

    private void GenerateHubImplementation(SourceProductionContext context, CodeWriter source, HubInfo hub)
    {
        source.WriteLine();

        using (source.BlockComment())
        using (source.Namespace(hub.Type.Namespace.TrimPrefix("global::")))
        {
            source.WriteLine($"public partial class {hub.Type.Name}");
            using (source.Block())
            {
                source.WriteLine($"public static class ToClient");
                using (source.Block())
                {
                    WriteMessages(source, hub.ClientInterface);
                }
                source.WriteLine();
                source.WriteLine($"public static class ToServer");
                using (source.Block())
                {
                    WriteMessages(source, hub.ServerInterface);
                }
            }
        }
    }

    private void WriteMessages(CodeWriter source, InterfaceInfo interfaceInfo)
    {
        foreach (var method in interfaceInfo.Methods)
        {
            WriteMessage(source, method);
        }
    }

    private void WriteMessage(CodeWriter source, MethodInfo method)
    {
        using (source.XmlDoc())
        {
            using (source.Summary())
            {
                source.See(method.Name);
                source.WriteLine(" is derived from ");
                source.See(method.DeclaringType.ToGlobalName() + "." + method.Name + "(" +
                           string.Join(", ", method.Parameters.Select(p => p.Type.ToGlobalName())) + ")");
            }
        }

        source.Write($"public record {method.Name}(");
        for (int i = 0; i < method.Parameters.Length; i++)
        {
            if (i > 0) source.Write(", ");
            var p = method.Parameters[i];
            source.Write($"{p.Type.ToGlobalName()} {p.Name.ToPascalCase()}");
        }
        source.WriteLine(");");
    }
}


record HubInfo(TypeInfo Type, InterfaceInfo ClientInterface, InterfaceInfo ServerInterface);


record InterfaceInfo(TypeInfo Type, params MethodInfo[] Methods);

record MethodInfo(string Name, TypeInfo ReturnType, TypeInfo DeclaringType, params ParameterInfo[] Parameters);

record ParameterInfo(string Name, TypeInfo Type);

/// <summary> constructs  generic type info </summary> 
record TypeInfo(string Namespace, string Name, bool IsGeneric, params TypeInfo[] TypeParameters)
{
    /// <summary> constructs non-generic type info </summary> 
    public TypeInfo(string ns, string name, params TypeInfo[] typeParameters) : this(ns, name, typeParameters.Length > 0, typeParameters) { }
}

static class InfoExtensions
{
    public static string ToGlobalName(this TypeInfo typeInfo)
    {
        if (typeInfo.IsGeneric)
        {
            return $"global::{typeInfo.Namespace}.{typeInfo.Name}<{string.Join(", ", typeInfo.TypeParameters.Select(ToGlobalName))}>";
        }

        return $"global::{typeInfo.Namespace}.{typeInfo.Name}";
    }
}
